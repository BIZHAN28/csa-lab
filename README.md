# Лабораторная работа №3 "Эксперимент"

## Вариант
```
asm | risc | harv | mc -> hw | tick -> instr | struct | stream | port | pstr | prob1 | cache
```
 - Бижанов Расул Сунгатович P3206
 - Базовый вариант

### Расшифровка
   - Низкоуровневый язык ***Assembler*** с поддержкой меток
   - ***RISC*** архитектура процессора
   - ***Гарвардская архитектура*** (раздельная память для команд и данных)
   - Управление посредствам ***микрокода***
   - Симуляция с точностью до ***тактов***
   - Машинный код хранится как ***высокоуровневая структура***
   - ***Потоковый*** ввод-вывод (без прерываний)
   - Устройства ввода-вывода адресуются через ***порты*** (особые инструкции для ввода-вывода)
   - ***Pascal strings*** (длина строки + содержимое)
   - Project euler problem 1 (алгоритм для реализации на языке forth)
   - ~~Кэширование~~ (не реализовано)

## Оглавление
1. [Вариант](#вариант)
    - [Расшифровка](#расшифровка)
2. [Язык программирования](#язык-программирования)
   - [Синтаксис](#синтаксис)
   - [Семантика](#семантика)
   - [Литералы](#литералы)
   - [Типы аргументов](#типы-аргументов)
3. [Организация памяти](#организация-памяти)
4. [Система команд](#система-команд)
5. [Транслятор](#транслятор)
6. [Модель процессора](#модель-процессора)
7. [Тестирование](#тестирование)
8. [Общая статистика](#общая-статистика)

## Язык программирования

Реализуется подмножество языка Assembler для программ из задания. [Сами программы](algorithms). 

### Синтаксис

```ebnf
program ::= <section_code> <section_data> | <section_data> <section_code> | <section_code>
<section_data> ::= "section .data:" <data>
<section_code> ::= "section .code:" <code>
<data> ::= (<comment> | <variable>) <data>
<code> ::= (<comment> | <label> | <instruction>) <code>
<comment> ::= "#" <character>*
<label> ::= "."<name> ":"
<name> ::= [a-zA-Z]+
<variable> ::= <name> ":" (<int> | <string>)
<reg=> ::= "x0" | "x1" | "x2" | "x3" | "x4" | "x5" | "x6" | "x7" | "x8" | "x9" | "x10" | "x11" | "x12" | "x13" | "x14" | "x15"
<string> ::= '"' <character>* '"'
<character> ::= any printable ASCII character
<int> ::= - <DIGIT>+ | <DIGIT>+
<ter_ops> ::= ("add" | "sub" | "mod" | "div" | "and" | "or") " " (<reg> ", " <reg> ", " <reg>)
<bin_ops> ::= ("ld" | "st" | "mov" | "not") " " (<reg> ", " <reg>)
<un_ops> ::= ("inc" | "dec" | "neg") " "  (<reg>)
<imm_load> ::= "movi" " " (<reg> ", " (<name> | <int>))
<branch> ::= ("jmp" | "je" | "jg") " " (<label>)
<io_ops> ::= ("in" | "out") " " (<reg> ", " <reg>)
<zero_arg> ::= ("hlt" | "nop")
<instruction> ::= <ter_ops> | <bin_ops> | <un_ops> | <imm_load> | <branch> | <io_ops> | <zero_arg>
```

### Семантика
Код выполняется последовательно, одна инструкция за одной.

Список доступных [инструкций](). 

Помимо команд из системного уровня программисту доступны команды:

* `WORD <literal>` – объявить переменную в памяти.
* `BUF <amount>` – инициализировать в памяти буфер на `amount` элементов.
Содержимое буфера по умолчанию `0`

Метки определяются на отдельной строке исходного кода:

```asm
label:
        word 42
```

Далее метки могут быть использованы (неважно, до или после определения) в исходном коде:

```asm
label_addr:
        word label ; в памяти будет хранится адрес на ячейку памяти word 42
```

Метки не чувствительны к регистру. Повторное определение меток недопустимо.  
Определение меток `label` и `LaBeL` считается повторением.

Использовать определённую метку можно неограниченное число раз.  
Транслятор поставит на место использования метки адрес той инструкции, перед которой она определена.

Любая программа обязана иметь метку `start`, указывающую на первую исполняемую команду.

### Литералы
   1. Любое целое число воспринимается как команда положить это число на вершину стека.
   2. Строка (область ограниченная `"`) воспринимается как инициализация строки в памяти. Ее можно вывести с помощью `.`. Пример этого в программе [hello world](algorithms/hello_world.fth).  

## Организация памяти

* Вся внешняя память - статическая, SRAM
* Машинное слово – не определено. Инструкции хранятся в высокоуровневой структуре данных.
* Размер операнда – не определен. Интерпретируется как знаковое целое число.
* Программа и данные хранятся в раздельной памяти согласно Гарвардской архитектуре.
  Программа состоит из набора инструкций, последняя инструкция – `HALT`.
* Доступ к памяти осуществляется по адресу из специального регистра.
* Адресация – прямая, абсолютная, доступ к словам.
* Программист не взаимодействует с адресами памяти данных на прямую.
  Транслятор сам решает, в каком месте выделить память под программу и под данные программы.
* Литералы - знаковые числа. Константы отсутствуют.

## Система команд

Особенности процессора:

* Машинное слово – не определено.
* Тип данных - знаковые числа или символы ascii (в рамках модели на python эти типы так и хранятся)
* Доступ к памяти осуществляется по адресу из специального регистра
* Поток управления:
  * Значение `PC` инкриминируется после исполнения каждой инструкции;
  * Условные (`JG`, `JE`) и безусловные (`JUMP`) переходы;
  * Микропрограммное управление - каждый такт выполняется одна микрокоманда и посредствам счетчика микрокоманд решается, какая станет следующей. 

Набор инструкций:

* `nop` – нет операции.
* `in { taget_reg }` - ввод данных из устройств ввода вывода в `taget_reg`.
* `out { source_reg }` - вывод данных в устройства ввода вывода из `source_reg`.
* `mov { taget_reg, source_reg }` - переложить значение из `source_reg` в `taget_reg`.
* `movi { taget_reg, immediate }` - положить значение `immediate` в `taget_reg`.
* `ld { target_reg, address_reg }` – загрузить в `taget_reg` из памяти значение по адресу из `address_reg`.
* `st { address_reg, register }` – положить значение в память по адресу из `address_reg`.
* `inc { register }` - увеличить значение регистра на 1.
* `dec { register }` - уменьшить значение регистра на 1.
* `neg { register }` – записать в регистр значение `-register`.
* `add { taget_reg, source_reg_1, source_reg_2 }` – положить в `taget_reg` результат операции сложения `source_reg_1 + source_reg_2`.
* `sub { taget_reg, source_reg_1, source_reg_2 }` – положить в `taget_reg` результат операции вычитания `source_reg_1 + source_reg_2`.
* `div { taget_reg, source_reg_1, source_reg_2 }` – положить в `taget_reg` результат операции деления `source_reg_1 / source_reg_2`.
* `mod { taget_reg source_reg_1, source_reg_2 }` – положить в `taget_reg` результат операции взятия остатка от деления `source_reg_1 % source_reg_2`.
* `and { taget_reg, source_reg_1, source_reg_2 }` – положить в `taget_reg` результат операции логического И `source_reg_1` и `source_reg_2`.
* `or { taget_reg, source_reg_1, source_reg_1 }` – положить в `taget_reg` результат операции логического ИЛИ `source_reg_1` или `source_reg_2`.
* `not { target_reg, source_reg }` - положить в `taget_reg` результат операции логического НЕ `source_reg`.
* `jg { register, program_address }` – если значение в `register` больше 0, начать исполнять инструкции по указанному адресу. Условный переход.
* `je { register, program_address }` – если значение в `register` равно 0, начать исполнять инструкции по указанному адресу. Условный переход.
* `jump { program_address }` – безусловный переход по указанному адресу.
* `hlt` – остановка тактового генератора.

Взятие операнда из регистра - `{ register }` или `{ source_reg }`. \
Направление результата в регистра `{ taget_reg }`
s
Согласно [варианту](#вариант) машинный код хранится в высокоуровневой структуре. 
Это реализуется списком словарей (в python соответствуют json объектам).
Один элемент списка — это одна инструкция.
Индекс инструкции в списке – адрес этой инструкции в памяти команд.

Пример машинного слова:
```json
{
  "opcode": "LIT",
  "operand": 2
}
```

Где:
* `opcode` – строка с кодом операции
* `operand` – аргумент команды (обязателен для инструкций с операндом)

Система команд реализована в модуле [isa](/isa.py).

## Транслятор
## Модель процессора
## Тестирование
## Общая статистика
